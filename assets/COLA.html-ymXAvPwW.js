import{_ as h}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as n,o as i,c,a as e,b as a,d,f as t}from"./app-302Urp1_.js";const s={},o=t(`<p>https://github.com/alibaba/COLA</p><h1 id="cola" tabindex="-1"><a class="header-anchor" href="#cola" aria-hidden="true">#</a> COLA</h1><h2 id="cola-1" tabindex="-1"><a class="header-anchor" href="#cola-1" aria-hidden="true">#</a> COLA 1</h2><p>https://blog.csdn.net/significantfrank/article/details/85785565 因为系统变的复杂臃肿，最终形成了COLA，一个基于扩展点+元数据+CQRS+DDD的应用架构；</p><h2 id="系统复杂性来源四个方面" tabindex="-1"><a class="header-anchor" href="#系统复杂性来源四个方面" aria-hidden="true">#</a> 系统复杂性来源四个方面：</h2><h3 id="可扩展性差" tabindex="-1"><a class="header-anchor" href="#可扩展性差" aria-hidden="true">#</a> 可扩展性差</h3><p>扩展点（Extension Point），或者叫插件（Plug-in）的设计。 字段扩展。</p><h3 id="面向过程" tabindex="-1"><a class="header-anchor" href="#面向过程" aria-hidden="true">#</a> 面向过程</h3><p>工程师要具备业务Sense，产品Sense，数据Sense，算法Sense，还要有工程能力。 不了解SOLID原则，不懂设计模式，不会画UML图，或者从来不会运实践。 （抽象能力，设计模式，架构模式，UML，以及阅读优秀框架源码） 不会进行领域建模 研读一下Eric Evans的《领域驱动设计》，升级认知。 DDD将业务语义显现化了。 Programs must be written for people to read, and only incidentally for machines to execute</p><h3 id="分层不合理" tabindex="-1"><a class="header-anchor" href="#分层不合理" aria-hidden="true">#</a> 分层不合理</h3><pre><code>All problems in computer science can be solved by another level of indirection
</code></pre><p>分层最大的好处就是分离关注点，让每一层只解决该层关注的问题，从而将复杂的问题简化，起到分而治之的作用。</p><h3 id="随心所欲" tabindex="-1"><a class="header-anchor" href="#随心所欲" aria-hidden="true">#</a> 随心所欲</h3><p>缺少规范和约束 Just because you can, doesn’t mean you should 架构的约束毕竟有限，更多的还是要靠Code Review</p><h2 id="复杂性应对之道" tabindex="-1"><a class="header-anchor" href="#复杂性应对之道" aria-hidden="true">#</a> 复杂性应对之道</h2><h3 id="扩展点设计" tabindex="-1"><a class="header-anchor" href="#扩展点设计" aria-hidden="true">#</a> 扩展点设计</h3><p>抽象的扩展点机制</p><h4 id="身份识别" tabindex="-1"><a class="header-anchor" href="#身份识别" aria-hidden="true">#</a> 身份识别</h4><p>TODO</p><h4 id="扩展点" tabindex="-1"><a class="header-anchor" href="#扩展点" aria-hidden="true">#</a> 扩展点</h4><p>TODO</p><h3 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象" aria-hidden="true">#</a> 面向对象</h3><pre><code>SOLID是单一职责原则(SRP)，开闭原则(OCP)，里氏替换原则(LSP)，接口隔离原则(ISP)和依赖倒置原则(DIP)的缩写**，原则是要比模式（Design Pattern）更基础更重要的指导准则，是面向对象设计的Bible
</code></pre><h4 id="单一职责" tabindex="-1"><a class="header-anchor" href="#单一职责" aria-hidden="true">#</a> 单一职责</h4><p>反面就是上帝类揽一堆功能，导致内聚性差，难被复用，只能复制</p><h4 id="依赖倒置" tabindex="-1"><a class="header-anchor" href="#依赖倒置" aria-hidden="true">#</a> 依赖倒置</h4><h4 id="领域建模" tabindex="-1"><a class="header-anchor" href="#领域建模" aria-hidden="true">#</a> 领域建模</h4><pre><code>DDD不是一个架构，而是思想和方法论
</code></pre>`,28),l={href:"https://blog.csdn.net/significantfrank/article/details/79614915",target:"_blank",rel:"noopener noreferrer"},p={href:"https://blog.csdn.net/weixin_36380516/article/details/132614118",target:"_blank",rel:"noopener noreferrer"},u=t('<p>然而DDD是面向对象的，是一种知识丰富的设计（Knowledge Rich Design），怎么理解？，就是通过领域对象（Domain Object），领域语言（Ubiquitous Language）将核心的领域概念通过代码的形式表达出来，从而增加代码的可理解性。这里的领域核心不仅仅是业务里的“名词”，所有的业务活动和规则如同实体一样，都需要明确的表达出来。</p><h5 id="业务语义显性化" tabindex="-1"><a class="header-anchor" href="#业务语义显性化" aria-hidden="true">#</a> 业务语义显性化</h5><p>好的代码不仅要让程序员能读懂，还要能让领域专家也能读懂。</p><h5 id="通用语言" tabindex="-1"><a class="header-anchor" href="#通用语言" aria-hidden="true">#</a> 通用语言</h5><h3 id="分层设计" tabindex="-1"><a class="header-anchor" href="#分层设计" aria-hidden="true">#</a> 分层设计</h3><p>三个大的层次，分别是App层，Domain层和Infrastructure层</p><h3 id="规范设计" tabindex="-1"><a class="header-anchor" href="#规范设计" aria-hidden="true">#</a> 规范设计</h3><h4 id="放对位置" tabindex="-1"><a class="header-anchor" href="#放对位置" aria-hidden="true">#</a> 放对位置</h4><h4 id="贴好标签" tabindex="-1"><a class="header-anchor" href="#贴好标签" aria-hidden="true">#</a> 贴好标签</h4><h5 id="类名约定" tabindex="-1"><a class="header-anchor" href="#类名约定" aria-hidden="true">#</a> 类名约定</h5><h5 id="方法名约定" tabindex="-1"><a class="header-anchor" href="#方法名约定" aria-hidden="true">#</a> 方法名约定</h5><h5 id="错误码约定" tabindex="-1"><a class="header-anchor" href="#错误码约定" aria-hidden="true">#</a> 错误码约定</h5><p>主要分为<strong>系统异常和业务异常</strong> 系统异常是指不可预期的系统错误，如网络连接，服务调用超时等，是可以retry的；而业务异常是指有明确业务语义的错误，再细分的话，又可以分为参数异常和业务逻辑异常，参数异常是指用户过来的请求不准确，逻辑异常是指不满足系统约束，比如客户已存在。业务异常是不需要retry的。</p><table><thead><tr><th>错误类型</th><th>错误码约定</th><th>举例</th></tr></thead><tbody><tr><td>参数异常</td><td>P_XX_XX</td><td>P_CAMPAIGN_NameNotNull: 运营活动名不能为空</td></tr><tr><td>业务异常</td><td>B_XX_XX</td><td>B_CAMPAIGN_NameAlreadyExist: 运营活动名已存在</td></tr><tr><td>系统异常</td><td>S_XX_ERROR</td><td>S_DATABASE_ERROR: 数据库错误</td></tr></tbody></table><h5 id="domain-event约定" tabindex="-1"><a class="header-anchor" href="#domain-event约定" aria-hidden="true">#</a> Domain Event约定</h5><ul><li>service prodiver端即服务提供者；</li><li>service facade端即服务消费端（按照J2EE的标准称呼叫facade，还有人喜欢叫proxy端，消费端是中国人的说法）；</li></ul>',16);function f(b,_){const r=n("ExternalLinkIcon");return i(),c("div",null,[o,e("p",null,[e("a",l,[a("复杂性应对之道 - 领域建模"),d(r)]),e("a",p,[a("事务脚本 vs 领域模型"),d(r)]),a(" 强烈建议使用DDD代替事务脚本（TS: Transaction Script）。因为TS的贫血模式，里面只有数据结构，完全没有对象（数据+行为）的概念，这也是为什么我们叫它是面向过程的原因。")]),u])}const m=h(s,[["render",f],["__file","COLA.html.vue"]]);export{m as default};
